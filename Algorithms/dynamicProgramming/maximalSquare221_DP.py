import itertools
from typing import List
# 这题动态规划纯属巧合,且治标不治本,如果换成最大长方形就必须老实用单调栈

class Solution:
    def maximalSquare(self, M: List[List[str]]) -> int:
        for i, j in itertools.product(range(len(M)), range(len(M[0]))):
            """
            动态规划的宗旨在于避免重复计算，并将其之前的结果保存下来
            """
            M[i][j] = 0 if M[i][j] == '0' else (1 + (0 if 0 in (i, j) else min(M[i - 1][j], M[i - 1][j - 1], M[i][j - 1], )))  #如果不加这个小if的话，第一列和第一行原本的1会变成2
        return max(itertools.chain(*M)) ** 2  # 将M视为元组

if __name__=="__main__":
    # matrix = [["1", "0", "1", "0", "0"],
    #           ["1", "0", "1", "1", "1"],
    #           ["1", "1", "1", "1", "1"],
    #           ["1", "0", "0", "1", "0"]]

    # matrix = [["1", "1", "1", "1", "0"],
    #           ["1", "1", "1", "1", "1"],
    #           ["1", "1", "1", "1", "1"],
    #           ["1", "1", "1", "1", "1"]]
    # matrix = [["0", "1"], ["1", "0"]]
    # matrix = [["1", "0", "1", "0", "0"],
    #           ["1", "0", "1", "1", "1"],
    #           ["1", "1", "1", "1", "1"],
    #           ["1", "0", "1", "1", "1"]]
    # matrix = [["0"]]
    matrix = [["0", "0", "0", "0", "0"],
              ["0", "1", "1", "1", "1"],
              ["0", "0", "0", "0", "0"],
              ["0", "1", "1", "1", "1"],
              ["0", "1", "1", "1", "1"]]

    print(Solution().maximalSquare(matrix))

